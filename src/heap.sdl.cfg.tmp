// ---------------- GENERIC TOOLS ----------------

//padding tool
GUumax padP2(GUumax n, GUumax p2);






// ---------------- USER SCALE ----------------

//size
GUumax heap__sz(ref r);

//new - free
ref  heap__new(GUumax len);
void heap__free(ref r);






// ---------------- MEMORY ACCESS ----------------

//fixed size, unsafe: read
GUu8  heap__unsafe_ru8( iref ir);
GUu16 heap__unsafe_ru16(iref ir);
GUu32 heap__unsafe_ru32(iref ir);
#ifdef ARCH64
GUu64 heap__unsafe_ru64(iref ir);
#endif

//fixed size, unsafe: write
void heap__unsafe_wu8( iref ir, GUu8  e);
void heap__unsafe_wu16(iref ir, GUu16 e);
void heap__unsafe_wu32(iref ir, GUu32 e);
#ifdef ARCH64
void heap__unsafe_wu64(iref ir, GUu64 e);
#endif

//fixed size, safe: read
GUu8  heap__safe_ru8( iref ir);
GUu16 heap__safe_ru16(iref ir);
GUu32 heap__safe_ru32(iref ir);
#ifdef ARCH64
GUu64 heap__safe_ru64(iref ir);
#endif

//fixed size, safe: write
void heap__safe_wu8( iref ir, GUu8  e);
void heap__safe_wu16(iref ir, GUu16 e);
void heap__safe_wu32(iref ir, GUu32 e);
#ifdef ARCH64
void heap__safe_wu64(iref ir, GUu64 e);
#endif

//makes no sens to read on variable size:
//  How can we know where to put the result if we don't know the size statically (at compile time) ?

//variable size, unsafe: write
void heap__unsafe_w(iref src, iref dst, GUumax size);

//variable size, safe: write
void heap__safe_w(iref src, iref dst, GUumax size);
